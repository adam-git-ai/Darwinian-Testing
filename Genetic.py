import numpy as np
import csv
import random
import copy
from random import choices
import operator
import logFails     # Logs parameter combinations which cause failures
import matplotlib.pyplot as plt
import os
import re

# Problem specific scripts that are required from the user
import read_data    # Import data
import system_under_test    # A script containing a model of the system under test, to which the test cases are communicated and tested.


class GeneticAlgorithm():

    def __init__(self, filename, i, maxSet, template, popSize, mutationRate, maxIterations, randomLower, randomUpper, initName, amountPops, initPopName):
        self.filename = filename
        self.tables = []    # An array where each element is the data of one TC. Extract: tables[0].states gets the states of the first TC
        self.i = i          # For remembering the index of the previous "iteration", so that new file names can be created rather than replacing previous ones.
        self.verdict = []   # An array containing test verdicts
        self.fitness = []   # An array containing fitnesses
        self.parametersets = {}     # A dictionary for the parameter sets, defined as {atc1: [[p1 p2 ... p15], [p1 p2 ... p15]...], ... atcN: [[p1 p2 ... p15], [p1 p2 ... p15]...]} (as matrices within the dict, each row is a different parameter set)
        self.maxSet = maxSet    # Maximum amount of new parameter sets to be generated
        self.template = template  # The original parameter setting for the given TC is stored here. The parameter sets are derived from this
        self.popSize = popSize    # Size of the populations, inputted as a portion of the amount of parameter sets, e.g. popSize = 0.1 * maxSet
        self.population = {}      # Collections of parameter sets, containing popSize parameter sets each
        self.populationFitness = {} # A dictionaty containing the fitness of each population
        self.popzFitness = []   # An array of respective population fitness, same content as self.populationFitness but in array form
        self.parents = {}
        self.popVerdict = {}    # A dictionary containing the verdict of each respective parameter set as: {0: [p, f, p], 1: [f, p, p] ...}. Output from tester.
        self.maxFit = '' # Index of the population in self.population with highest fitness
        self.parentsIndex = '' # Index of the population in self.population which is to generate new populations, generated by Pie Chart Selection, replacing maxFit.
        self.mutationRate = mutationRate  # The probability that mutation will occur
        self.newParametersets = {}  # A dict containing parameter sets generated by crossover.
        self.maxIterations = maxIterations
        self.randomLower = randomLower
        self.randomUpper = randomUpper
        self.totalsum = ''  # (Current) Total sum of fails
        self.sumFailVec = []
        self.initName = initName    # Filename of file containing initial populations
        self.amountPops = amountPops
        self.initPopName = initPopName


    def _initialise(self, filename, i):      # Starts by reading the TC data (tables_x.txt), create a population of parameter sets
        for file in filename:
            self.i = i
            self.tables.append(read_data.main(file,i))
            i += 1
            

    def _random_selection(self):   # Chooses a column (variable) randomly. There are 15 parameters, two of which are not chosen:
        col = random.randint(0,len(self.template)-1) # Chooses one parameter by random to generate new parameter sets by altering one parameter.
        row = random.randint(0,len(self.template) - 1) # Random row
        return row, col


    def _generate_parameter_sets(self, tables, maxSet):        # Generate new parameter sets (maxSet amount) from an original parameter set (from TC)

        template = []
        template.append(tables[0].parameters["parameters0"])
        
        # If one desires to evaluate all of the parameters, leave the following row as is.
        assessed_variables = template

        # If one desires to evaluate only some of the parameters, remove the row above and use the rows below.
        # assessed_variables = []
        # assessed_variables.append(template[0][0])   # Copy this line to select the desired parameters.

        self.template = assessed_variables
        self.parametersets.update({"original": self.template})

        def _alter(template):    # Creates variations of the initial parameter set in order to generate populations.
            sd = []         # Temporary array for storage of variables.
            temporary = copy.deepcopy(template) # Copy of the parameter set, template
            x = self._random_selection()     # Generates a random row and column number, to be used for altering
            row = x[0]
            col = x[1]
            addRandom = random.randint(self.randomLower,self.randomUpper)//10      # A random integer between 1 and 8 to be added to the parameter
            option = 1

            if option == 1:     # Add the random integer to a randomly selected column
                temporary[col] += addRandom
                sd.append(temporary)

            if option == 2:     # Add a random integer to only one index of the array
                p = 0
                for each in temporary:
                    if p == row:
                        each[col] += addRandom
                    sd.append(each)
                    p += 1

            if option == 3:     # Add a random integer to a randomly selected row
                p = 0
                for each in temporary:
                    if p == row:
                        for zz in range(0,len(each)):
                            each[zz] += addRandom
                    sd.append(each)
                    p += 1
            return sd

        for j in range(0, maxSet):
            newSet = copy.deepcopy(_alter(assessed_variables))
            self.parametersets.update({j: newSet[0]})


    def _population(self, in_parametersets):  # Selects populations of N parameters sets each. Fitness is calculated based on these populations, the pop with highest fitness is chosen for mutation.
        self.population.clear() # So that values from previous iterations are cleared
        for ou in range(0, self.maxSet//self.popSize):   # Generates maxSet/popSize amount of populations, e.g. popSize = 3, maxSet = popSize * 4 gives 4 populations.
            indices = random.sample(range(0, len(in_parametersets)-1), self.popSize) # Randomly picked indices of the parameter sets, for choosing parameter sets for the populations
            self.population.update({ou: indices})   # Indices of the parameter sets. These indices can be used to extract the corresponding verdicts (same indices as parameter sets)


    def _tester(self):      # The TC's are communicated to a system under test (Python script or physical)
        self.popVerdict.clear() # So that values from previous iterations are cleared
        self.popVerdict = system_under_test.read(self)  # Returns a dict containing the verdicts for each population
        logFails.storeFails(self)   # Stores the failed parameter sets (TC's) in database.


    def _calculate_fitness(self):   # Calculate fitness of the populations
        self.totalsum = 0
        for oi in range(0,len(self.popVerdict)):        # Sums up the fails for each population, the higher the sum the higher the fitness of that population.
            fit = 0
            for verdict in self.popVerdict[oi]:
                if verdict == 'fail':               # Fitness score of the population is increased for each failed test case
                    fit += 1
                    self.totalsum += 1   # Total sum of fails among all populations, to be used for Pie Chart Selection of a parent population.
            self.populationFitness.update({oi: fit})        # Calculates the amount of errors that each population yields.

        def _rouletteSelection(self):     # Selecting population with Roulett/Pie Chart Selection
            rand = random.randint(0, self.totalsum)
            partialSum = 0
            for x in range(0,len(self.population)):
                partialSum += self.populationFitness[x]
                if partialSum >= rand:
                    return x

        self.parentsIndex = _rouletteSelection(self)  # The index of populations (in self.population) which is to be the parent for generating new populations of parametersets

        def _makeParent(self):
            i = 0
            for sett in self.population[self.parentsIndex]:          # Assigns the parameter sets which constitute the population to a dictionary
                self.parents.update({i: self.parametersets[sett]})
                i += 1
        
        self.parents.clear()
        _makeParent(self)      # Now we have what is necessary for crossover and mutation.


    def _mutate(self,index):      # Mutate with a probability (p = x %) one/more randomly chosen variable(s)
                                  # Input can be changed to dictionary of parameter sets, remove 'index' input in that case.
        x = self._random_selection()
        col = x[1]
        randomNr = random.randint(self.randomLower,self.randomUpper)//10      # A random integer between 1 and 8 to be added to the parameter
        self.newParametersets[index][col] = randomNr


    def _crossover(self):
        newSet = {}
        absoluteIndex = 0
        for zx in range(0, self.maxSet//self.popSize):
            foster = copy.deepcopy(self.parents)        # "Foster parents", a deepcopy of self.parents, needed since self.parents will be changed otherwise, not desired.
            selectParents = random.sample(range(0,len(foster)), len(foster))   # Selects two parents from self.parents to be crossed over
            col1 = self._random_selection()[1]   # The column which is to be crossed over between the parents

            intermediate = '' 
            intermediate = foster[selectParents[0]][col1]

            foster[selectParents[0]][col1] = foster[selectParents[1]][col1]
            foster[selectParents[1]][col1] = intermediate

            for index in foster:        # Saves the generated parameter sets in the dict newSet
                vec = []
                for ueach in foster[index]:
                    vec.append(ueach)
                newSet.update({absoluteIndex + index: vec})
            absoluteIndex += index

        self.newParametersets = newSet
        
        for h in range(0,len(self.newParametersets)):   # Mutation of self.newParameters with probability self.mutationRate
            population = [0, 1]     # For mutation
            weights = [1-self.mutationRate, self.mutationRate]    # The distribution of don't mutate vs mutate
            mutation = choices(population,weights)[0]
            if mutation == 1:
                self._mutate(h)


    def _plot(self, plotBefore, plotAfter):      # Plots the results

        plt.figure(1, figsize=(10, 5))
        plt.subplot(121)
        barWidth = 0.3
        bars1 = plotBefore
        bars2 = plotAfter
        r1 = np.arange(len(bars1))
        r2 = [x + barWidth for x in r1]
        plt.bar(r1, bars1, width = barWidth, color = 'white', edgecolor = 'black', capsize=7, label='First iteration')
        plt.bar(r2, bars2, width = barWidth, color = 'dimgrey', edgecolor = 'black', capsize=7, label=str(self.maxIterations)+':th iteration')
        plt.xticks([r + barWidth for r in range(len(bars1))], ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10'])
        plt.ylabel('Fitness score')
        plt.legend()
        plt.title('Mutation rate: '+str(self.mutationRate) + '. Population size: ' + str(self.popSize))
        plt.subplot(122)
        plt.title('Total fails')
        plt.xlabel('Iterations')
        plt._plot(self.sumFailVec, 'dimgrey')
        plt.grid()
        plt.ylabel('Fails')
        plt.show()
        

    def _loop(self):     # Loops the genetic algorithm in order to detect faults within the tested system

        self.sumFailVec = []
        limit = 5
        for iterations in range(0, self.maxIterations):
            self._population(self.newParametersets)
            self._tester()
            self._calculate_fitness()
            self.sumFailVec.append(self.totalsum)
            self._crossover()
            self.parametersets = self.newParametersets

            if iterations == limit:
                pass

            # Dynamically decreasing mutation rate. Halved each iteration.
            if self.mutationRate > 0:
                self.mutationRate = self.mutationRate / 2


    def _save_initial(self):
        f = open(self.initName, "w")
        for index in range(0,len(self.parametersets)-1):
            f.write(str(self.parametersets[index]).strip('[] '))
            f.write("\n")
        f.close

        g = open(self.initPopName, "w")
        for yndex in range(0,len(self.population)):
            g.write(str(self.population[yndex]).strip('[] '))
            g.write("\n")
        g.close


    def _read_existing(self):
        f = open(self.initName, "r")
        j = 0
        for row in f:
            vec = [int(s) for s in re.findall(r'\b\d+\b', row)]
            if j == 0:
                self.parametersets.update({"original": vec})
                self.template = vec
            self.parametersets.update({j: vec})
            j += 1
        
        f.close
        g = open(self.initPopName, "r")
        i = 0
        for cow in g:
            vex = [int(s) for s in re.findall(r'\b\d+\b', cow)]
            self.population.update({i: vex})
            i += 1
        
        g.close


    def _run(self):
        if os.path.isfile('./init_popSize_' + str(self.popSize) + '_pops_' + str(self.amountPops) + '.txt') == False:
            self._initialise(self.filename, self.i)    # Converts the parameters from the inputted stripped TC into arrays named self.tables
            self._generate_parameter_sets(self.tables, self.maxSet)# Generates a set of popSize * maxSet parameter configurations based on self.tables
            self._population(self.parametersets)  # Through random selection of the available parameter set, maxSet/popSize populations are formed containing popSize parameters each. Type: dictionary
        else:   # Loads the files from database
            self._read_existing()

        print(self.population)
        self._tester()  # A code which acts as a tester. Takes in the generated self.population and generates verdicts for each parameter set. Returns self.popVerdict, a dict with P/F for each set
        self._calculate_fitness() # Takes self.popVerdict and sums all pass & fails for each population. Selects one population with Roulette Selection as a parent population, self.parents, for generating new populations
        self._crossover()# Deepcopies self.parents and does crossover between the parameter sets in the population to generate len(self.populations) populations, each containing popSize parameter sets.
                          # Does mutation with probability mutationRate. A dictionary, self.newParametersets, is generated containing new parameter sets. New populations are to be formed from these and l
        self._save_initial()
        plotBefore = []
        for each in range(0,len(self.populationFitness)):
            plotBefore.append(self.populationFitness[each])
        logFails.storeFails(self)   # Stores the failed parameter sets (TC's) in database.
        self._loop()
        logFails.storeFails(self)   # Stores the failed parameter sets (TC's) in database.
        plotAfter = []
        for each in range(0,len(self.populationFitness)):
            plotAfter.append(self.populationFitness[each])
        self._plot(plotBefore, plotAfter)


i = 1
filename = ["tables_" + str(i) + ".txt"] # Name of the file containing initial data
maxIterations = 50     # Amount of iterations
mutationRate = 0.1     # Initial mutation rate
popSize = 10            # The amount of parameter sets in a population
populations = 5         # The amount of populations
maxSet = popSize * populations    # Maximum amount of generated sets
randomLower = 10        # Boundaries on randomly generated numbers. Divided by 10 in GA, thus 10 gives 1 in the GA.
randomUpper = 50

initName = 'init_popSize_' + str(popSize) + '_pops_' + str(populations) + '.txt'        # Name of output file names
initPopName = 'init_popSize_' + str(popSize) + '_pops_' + str(populations) + 'POPULATION.txt'

GA = GeneticAlgorithm(filename,i, maxSet, [], popSize, mutationRate, maxIterations, randomLower, randomUpper, initName, populations, initPopName)
GA._run()